## step.1-1 : とりあえずインライン・アセンブラを書いてみよう

実際に実行可能なアセンブラを含んだ簡単なコードを書いてみます。  

### ソースコード
```
#include <Arduino.h>

void setup(void)
{ delay(1000); }

void loop(void)
{
  delay(1000);
  printf("loop:\n");

  for (int32_t y = 0; y < 5; ++y) {
    for (int32_t x = 0; x < 5; ++x) {
      int32_t val;
      __asm__ (                 // インライン・アセンブラの記述開始
        "add %0, %1, %2 \n"     // アセンブラコードを含む文字列  val = x + y;
        : "=r" ( val )          // output-list:  変数への出力: val = %0 となる
        : "r" ( x ), "r" ( y )  // input-list:   変数から入力: %1=x、%2=y となる
        :                       // clobber-list: この例では使用しない
      );                        // インライン・アセンブラの記述終了
      printf("   %d + %d = %d", x, y, val);
    }
    printf("\n");
  }
}
```

### 実行結果
```
loop:
   0 + 0 = 0   1 + 0 = 1   2 + 0 = 2   3 + 0 = 3   4 + 0 = 4
   0 + 1 = 1   1 + 1 = 2   2 + 1 = 3   3 + 1 = 4   4 + 1 = 5
   0 + 2 = 2   1 + 2 = 3   2 + 2 = 4   3 + 2 = 5   4 + 2 = 6
   0 + 3 = 3   1 + 3 = 4   2 + 3 = 5   3 + 3 = 6   4 + 3 = 7
   0 + 4 = 4   1 + 4 = 5   2 + 4 = 6   3 + 4 = 7   4 + 4 = 8
```

### 概要説明
この例はC/C++のソースコード内にアセンブラコードを `__asm__ ();` のカッコで囲んで埋め込む「インライン・アセンブラ」と呼ばれる記述方法になります。  
この例でのアセンブラの内容は、C/C++では ` int32_t val = x + y; ` と記述できる内容です。  
二重のforループの中で val=x+y を実行した結果を printf で標準出力に表示するコードです。  
```
__asm__ (                 // インライン・アセンブラの記述開始
  "add %0, %1, %2 \n"     // アセンブラコードを含む文字列  val = x + y;
  : "=r" ( val )          // output-list:  変数への出力: val = %0 となる
  : "r" ( x ), "r" ( y )  // input-list:   変数から入力: %1=x、%2=y となる
  :                       // clobber-list: この例では使用しない
);                        // インライン・アセンブラの記述終了
```
この例では `add` の行のみがアセンブラで、続く3行は C/C++とアセンブラとの値の受け渡しのための記述です。  
アセンブラコード内にC/C++の変数名をそのまま記述することはできないため、こういった記述が必要になります。  

### C/C++の変数とアセンブラの汎用レジスタ
C/C++の世界での変数の役割を果たすものは、アセンブラの世界では一般に「汎用レジスタ(general register)」と呼ばれます。  
Xtensa ではこれを「アドレスレジスタ」と呼称しており、32bitの値を扱える `a0` ~ `a15` の合計16個が用意されています。  
int32_t,uint32_t型として使える変数のようなものが16個ある、とイメージして頂ければ良いと思います。  

### output-list / input-list / clobber-list
アセンブラコードの文字列の後に `:` コロンで区切って、`output-list`、`input-list`、`clobber-list` と呼ばれる記述をします。  
各リストはカンマで区切って複数記述できます。使用しない場合は `:` コロンのみ記述して中身を省略してもよいです。  
`output-list` 、 `input-list` に記述した変数は、`%0` から順に番号が割当てられ、アセンブラコード内に記述が可能になります。
今回の例では `val` が `%0` 、 `x` が `%1` 、`y` が `%2` になります。
実際にはコンパイラが `a0` ~ `a15` の中からどれかを選択してコンパイル時に置き換えて処理しています。
どのレジスタが使用されるかはコンパイラ任せとなります。  

アドレスレジスタの個数は16個ですから、インライン・アセンブラとの受渡しに使える変数の個数にも上限があります。
インライン・アセンブラの外側の処理の都合もあるため、16個すべてをC/C++との受け渡しに使用することはできませんから、なるべく個数を少なく抑えることが望ましいです。  

`clobber-list` は今回の例では使用していませんが、アセンブラコード内で値を変えたレジスタがある場合に、そのことをコンパイラに知らせるために使います。  

### アセンブラコード部
今回の例では1行だけですが、`add` の行がアセンブラコードの記述になります。
`add` 命令には続けて3つのアドレスレジスタの記述が必要で、後ろ2つのアドレスレジスタを合算した値が、1つめのアドレスレジスタに代入されます。  
今回の例では `add %0,%1,%2` ですから、`%0 = %1 + %2` という意味になります。`output-list` `input-list` の記述により、`%0` は `val` 、 `%1` は `x` 、 `%2` は `y` ですから、`val = x + y` という動作になります。

### 複数行のアセンブラコードの記述
アセンブラの記述は基本的には 1行に 1つの命令を書き、改行で区切って次の命令を記述します。  
インライン・アセンブラではC/C++のコード内に文字列の形で書込むため、各行の文字列の末尾に `\n` を置いて改行とするのが良いでしょう。  

<hr>
今回はここまでです。C/C++のソースコード内にアセンブラコードを書込む方法の紹介でした。
