## step.1-2 : 複数行のインライン・アセンブラを書いてみよう

step.1-1の例は短すぎたので、今回は複数行を含むアセンブラコードを書いてみます。  

### ソースコード
```
#include <Arduino.h>

void setup(void)
{ delay(1000); }

void loop(void)
{
  delay(1000);
  printf("loop:\n");

  uint32_t array_size = 6;  // 配列の要素数
  int32_t src[array_size];  // 元データの配列
  int32_t dst[array_size];  // 結果データの配列

  for (int x = 0; x < array_size; ++x) {
    src[x] = x;             // 元データの準備
  }

  for (int y = 0; y < 6; ++y) {
    __asm__ (
      "   loop    %3, LABEL_LOOP  \n"   // 次の行からLABEL_LOOPの前の行まで array_size の回数ループする
      "   l32i    a15,%1, 0       \n"   // a15 = src[0]; 元データ 4Byte読取り
      "   add     a14,a15,%2      \n"   // a14 = a15 + %2  a14の中身は y と元データ配列の値の合計値になる
      "   s32i    a14,%0, 0       \n"   // dst[0] = a14;   結果データの配列に4Byte保存
      "   addi    %1, %1, 4       \n"   // %1 += 4;  元データのアドレスを 4 進める
      "   addi    %0, %0, 4       \n"   // %0 += 4;  結果データのアドレスを 4 進める
      "LABEL_LOOP:                \n"   // ラベル。この前の行がループの終端となる
      : // output-list       この例では不使用
      : // input-list        レジスタに値を渡す変数を列挙
        "r" (dst),        // %0 = dst;    結果データの配列アドレス
        "r" (src),        // %1 = src;    元データの配列アドレス
        "r" (y),          // %2 = y;      加算する値
        "r" (array_size)  // %3 = array_size;
      : // clobber-list      使用したレジスタを列挙
        "a14","a15"       // a14とa15の値が変わった事をコンパイラに知らせる
    );

    for (int x = 0; x < array_size; ++x) {  // 結果をprintfで出力
      printf("   %d + %d = %d", src[x], y, dst[x]);
    }
    printf("\n");
  }
}
```

### 実行結果
```
loop:
   0 + 0 = 0   1 + 0 = 1   2 + 0 = 2   3 + 0 = 3   4 + 0 = 4   5 + 0 = 5
   0 + 1 = 1   1 + 1 = 2   2 + 1 = 3   3 + 1 = 4   4 + 1 = 5   5 + 1 = 6
   0 + 2 = 2   1 + 2 = 3   2 + 2 = 4   3 + 2 = 5   4 + 2 = 6   5 + 2 = 7
   0 + 3 = 3   1 + 3 = 4   2 + 3 = 5   3 + 3 = 6   4 + 3 = 7   5 + 3 = 8
   0 + 4 = 4   1 + 4 = 5   2 + 4 = 6   3 + 4 = 7   4 + 4 = 8   5 + 4 = 9
   0 + 5 = 5   1 + 5 = 6   2 + 5 = 7   3 + 5 = 8   4 + 5 = 9   5 + 5 = 10
```

### 概要説明
内容的には前回と同じく単純な加算処理ですが、今回はアセンブラ側でもループ処理を行います。  
C/C++側で配列を2つ用意しておき、`src` は元データ、`dst` は結果データとして使用します。  
アセンブラに渡す変数は、`dst` のアドレス・`src` のアドレス・加算する値・配列のサイズです。  
`src` 配列から読み出した値に加算した結果を `dst` 配列に保存します。


### clobber-listの記述とアドレスレジスタの使用
今回の例では、アドレスレジスタ `a14` `a15` を使用しています。
これらのレジスタの値を変えたことをコンパイラに知らせるため、 `clobber-list` に記述が必要です。  
```
__asm__ (
～～ 省略 ～～
  : // output-list
  : // input-list
～～ 省略 ～～
  : // clobber-list      使用したレジスタを列挙
    "a14","a15"       // a14とa15の値が変わった事をコンパイラに知らせる
```
これを怠ると、アセンブラコードを実行した後の処理が正常に動作しなくなる可能性があります。  

なお、アドレスレジスタは16個あるので、わかりやすく若い番号 `a0` 側から順に使おう…と考えてしまうところですが、現時点ではひとまず、`a15` 側から逆順に使用した方が良い、と考えてください。  
詳細は別の機会に説明したいと思いますが、 `a0` と `a1` には特別な役割があり、 `clobber-list`に記述しても、値を書き換えた場合 正しく動作しなくなります。`a2` 以降は `clobber-list` に記述すれば正しく動作しますが、若い番号の方は C/C++側で既に使用中の可能性が高く、コンパイラの調整によって余分な迂回処理が追加される可能性があります。  

他の手段として、`input-list` にダミーの変数を追加しておき、`%4` 等の代替記述を用いることで、どのアドレスレジスタを使用するかをコンパイラに任せる方法もあります。


### アセンブラコード部
今回の例はラベルの行を含めて7行あります。 1行に 1つの命令を書き、改行で区切って次の命令を記述します。  
各行末尾のコメントから大体の処理の流れはご理解頂けると思いますが、順に追って説明していきます。

#### loop命令とラベルによるループ処理
今回の例では、ループ処理を行う `loop` 命令を使用しています。
他のCPUのアセンブラを知っている人は、分岐命令と回数カウンタの減算(または加算)を組み合わせる方法をご存知かも知れません。ESP32も同じ方法を使うことができますが、`loop` 命令の方が動作が速く、記述が簡単なため、今回はこれを使用しています。  

`loop` 命令には続けて1つのアドレスレジスタと、ループ終端位置の記述が必要です。アドレスレジスタに入っている値の回数だけループします。  
今回の例では `loop %3, LABEL_LOOP` です。 `input-list` の記述により `%3` は `array_size` 、C/C++側の記述で `array_size = 6;` ですから、6回ループします。 ループの範囲は `loop` 命令の次の行から `LABEL_LOOP:` の前の行まで、となります。   
```
uint32_t array_size = 6;  // 配列の要素数
～～ 省略 ～～
__asm__ (
  "   loop    %3, LABEL_LOOP  \n"   // ループ開始。この次の行からLABEL_LOOPの前の行まで array_size の回数ループする
～～ 省略 ～～
  "LABEL_LOOP:                \n"   // ラベル。先頭のloopでこれを指定しているので、この前の行がループの終端となる
  : // input-list        レジスタに値を渡す変数を列挙
    "r" (dst),        // %0 = dst;    結果データの配列アドレス
    "r" (src),        // %1 = src;    元データの配列アドレス
    "r" (y),          // %2 = y;      加算する値
    "r" (array_size)  // %3 = array_size;
～～ 省略 ～～
);
```
なお `loop` 命令を複数使ったネストできません。詳細は別の機会に説明したいと思いますが、`loop` 命令専用の特殊レジスタが(アドレスレジスタとは別に)存在しており、`loop` 命令を実行すると、この特殊レジスタの値が更新されます。そのためネストさせた場合は外側の `loop` が無効化し、内側の `loop` のみが動作します。  

`loop` 命令に使用したアドレスレジスタは、ループ内で別の用途に使用して値を書き換えても構いません。ループカウンタの役割として使われそうに見えるかも知れませんが、実際には `loop` 命令専用の特殊レジスタにループ回数が記録されるため、アドレスレジスタは最初にループ回数を知らせる目的でのみ使用されています。

#### l32i命令による 4Byte読み出し
C/C++側から受け取った `src` 配列から値を読み出すために、 `l32i` 命令を使用しています。メモリからアドレスレジスタに読み出す命令を、ロード命令と言います。  
`l32i` 命令には続けて2つのアドレスレジスタと、アドレスのオフセット量の記述が必要です。
2つめのアドレスレジスタの値にオフセット量を加えたアドレスのメモリから 4Byte 読取り、結果が 1つめのアドレスレジスタに代入されます。  
今回の例では `l32i a15,%1,0` です。 `input-list` により `%1` には `src` 配列のアドレスが入っています。オフセット量は `0` ですから、`src` の指し示すアドレス +0 の位置のメモリから 4Byte 読取って `a15` に代入されます。  

#### add命令による加算
前回の例でも使用した `add` 命令を使い、今回も加算を行います。
今回の例では `add a14,a15,%2` 、`input-list` により `%2` は `y` ですから、 `a14 = a15 + y` となります。  
なお 1つめのアドレスレジスタも `a15` にして `add a15,a15,%2` としても構いません。今回の例では `clobber-list` に複数のレジスタ記述を例示したかったので、敢えて `a14` に結果を入れましたが、実際の場面では、使用するレジスタを削減するため `a15` に結果を入れたほうが良いでしょう。  

#### s32i命令による 4Byte書き込み
C/C++側から受け取った `dst` 配列に値を書き込むために、 `s32i` 命令を使用しています。アドレスレジスタからメモリに書き込む命令を、ストア命令と言います。  
`s32i` 命令には続けて2つのアドレスレジスタと、アドレスのオフセット量の記述が必要です。
2つめのアドレスレジスタの値にオフセット量を加えたアドレスから 4Byte の範囲のメモリに、1つめのアドレスレジスタの値が書き込まれます。  
今回の例では `s32i a14,%0,0` です。 `input-list` により `%0` には `dst` 配列のアドレスが入っています。オフセット量は `0` ですから、`dst` の指し示すアドレス +0 から4Byteの範囲のメモリに `a14` の値が書き込まれます。  

#### addi命令による固定値の加算
ループ中に `%0` と `%1` のアドレスを進めるために `addi` 命令を使用しています。
`addi` 命令には続けて2つのアドレスレジスタと、加算する値の記述が必要です。2つめのアドレスレジスタに加算した結果が、1つめのアドレスレジスタに代入されます。  
今回の例では `addi %0, %0, 4` と `addi %1, %1, 4` ですから、`%0 = %0 + 4` と `%1 = %1 + 4` となります。
C/C++的には `src ++` や `dst += 1` と書ける内容ですが、各配列の中身は `int32_t` 型ですから、配列の各要素は 4Byteあります。アセンブラコード側では C/C++側の型情報の影響を受けないため、4Byte単位でアドレスが進むように、`%0` と `%1` は `+4` して4Byte単位で進むようにしておく必要があります。

